import argparse
import time
from urllib.error import URLError
from urllib.request import Request, urlopen
import json
import logging
import os
from pathlib import Path
import mysql.connector

"""
	Following header is necessary for requesting golemio api.
	code copied from https://golemioapi.docs.apiary.io/#reference/public-transport/vehicle-positions/get-all-vehicle-positions
	access token generated by https://api.golemio.cz/api-keys/auth/sign-in
"""
headers = {
	'Content-Type': 'application/json; charset=utf-8',
	'x-access-token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImNpem1hcmZpbGlwQGdtYWlsLmNvbSIsImlkIjo3NiwibmFtZSI6bnVsbCwic3VybmFtZSI6bnVsbCwiaWF0IjoxNTcwNTQ2MTU2LCJleHAiOjExNTcwNTQ2MTU2LCJpc3MiOiJnb2xlbWlvIiwianRpIjoiMzAxYWNhNDUtNGRlNC00ZDRmLWI4NzAtMzQwMDQ5OTM1MzBhIn0.4rCELzCNY8XOSvjqQA7cKocPGJ8D2ezhXiWUkIRUNjg'
}

"""
	This function downloads file of given url request and returns decoded json object
"""
def downloadURL(request):
	webURL = urlopen(request)
	response_body = webURL.read()
	encoding = webURL.info().get_content_charset('utf-8')
	return json.loads(response_body.decode(encoding))


"""
			Following function parses multiple optional arguments or sets default value of them
			Learn 'help' arguments for more information
			Returns object of arguments
"""
def parse_arguments():
	parser = argparse.ArgumentParser()
	parser.add_argument("--veh_act_pos_fn", default="../data/veh_act_pos", type=str,
						help="The last generated output file")
	parser.add_argument("--update_time", default=20, type=int, help="Time to next request")
	parser.add_argument("--update_error", default=20, type=int, help="Update time if network error occurred")
	parser.add_argument("--log", default="../database_filler.log", type=str, help="Name of logging file")
	parser.add_argument("--trips_folder", default="../data/trips", type=str, help="Name of trips folder")
	args = parser.parse_args()
	return args


"""
	Returns geojson object
"""
def transfor_json_to_geojson(json_vehiclepositions):
	geojson_vehiclepositions = {}
	geojson_vehiclepositions["type"] = "FeatureCollection"
	geojson_vehiclepositions["timestamp"] = time.strftime("%Y-%m-%d-%H:%M:%S")
	geojson_vehiclepositions["features"] = []

	for bus_input_list in json_vehiclepositions["features"]:
		bus_properties = bus_input_list["properties"]["trip"]
		current_trip_gtfs_id = bus_properties["gtfs_trip_id"]
		bus_output_list = {}
		bus_output_list["type"] = "Feature"
		bus_output_list["properties"] = {}
		bus_output_list["properties"]["gtfs_trip_id"] = current_trip_gtfs_id
		bus_output_list["properties"]["gtfs_route_short_name"] = bus_properties["gtfs_route_short_name"]
		bus_output_list["geometry"] = {}
		bus_output_list["geometry"]["coordinates"] = bus_input_list["geometry"]["coordinates"]
		bus_output_list["geometry"]["type"] = "Point"
		geojson_vehiclepositions["features"].append(bus_output_list)
		return geojson_vehiclepositions


def actualize_json_file(json_string, path, mode, log_message):
	try:
		with open(path, mode) as f:
			f.seek(0)
			f.write(json.dumps(json_string))
			logging.info(log_message)
	except Exception as e:
		raise IOError(e)
	finally:
		f.close()


if __name__ == "__main__":
	args = parse_arguments()
	logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s', level=logging.INFO, filename=args.log,
						filemode='w')
	logging.info("Program has started")

	mydb = mysql.connector.connect(
			host="localhost",
			database="vehicles_info",
			user="vehicles_access",
			passwd="my_password"
		)
	mycursor = mydb.cursor()

	"""
		Main loop -- is repeating every {update_time} seconds
	"""
	while True:
		req_start = time.time()

		"""
			Actualize positions file with priority
		"""
		try:
			json_vehiclepositions = downloadURL(Request('https://api.golemio.cz/v1/vehiclepositions', headers=headers))
			actualize_json_file(transfor_json_to_geojson(json_vehiclepositions), args.veh_act_pos_fn, "w+",
								"Vehicle actual positions file updated")
		except URLError as e:
			logging.error("Network error: " + str(e))
			time.sleep(args.update_error - (time.time() - req_start))
			continue
		except IOError as e:
			logging.error("Write to file failed: " + str(e))
			time.sleep(args.update_error - (time.time() - req_start))
			continue

		for bus_input_list in json_vehiclepositions["features"]:
			""" Trip id se musi zahashovat pro effectivni vyhledavani v databazi """
			trip_id = bus_input_list["properties"]["trip"]["gtfs_trip_id"]
			sql_query = "SELECT COUNT(trip_id) FROM trips WHERE trip_id=(%s)"
			sql_values = (trip_id)
			mycursor.execute(sql_query, sql_values)
			result = mycursor.fetchall()

			trip_headsign = 0
			delay = bus_input_list["properties"]["last_position"]["delay"]
			shape_traveled = bus_input_list["properties"]["last_position"]["gtfs_shape_dist_traveled"]
			trip_no = bus_input_list["properties"]["trip"]["cis_short_name"]

		"""
			Following code tries to sleep {update_time} - time consumed above seconds
			if fails the main loop is repeated immediately
		"""
		try:
			time.sleep(args.update_time - (time.time() - req_start))
		except Exception as e:
			logging.warning("Sleep failed, " + str(e))
			continue

