%%% Fiktivní kapitola s ukázkami tabulek, obrázků a kódu

\chapter{Implementace}






\section{Modely}


Pro spočítání polynomiálního modelu se využívá knihovna sklearn konkrétně algoritmus zvaný Rigde, který sám o sobě hledá linární závislosti, nicméně vstupní hodnoty jsou mezi sebou náležitě pronásobeny tak, aby simulovali polynomiální funkci. Toho se dosáhne pomocí funkce PolynomialFeatures. Optimální stupeň polynomu se zjistí spočítáním modelu pro každý stupeň v rozumných mezích a nakonec se zvolí ten s nejmenší chybou. (TODO jak moc detailně se ma toto popisovat?)






\section{Vizualizace dat}

Data budou zobrazovány pomocí webové aplikace (klientská část) a ta bude stahovat data ze serverové části. Komunikační mapa ilustrující propojení těchto částí je zobrazena na diagramu \ref{fig:design_diagram}.

\subsection{Klientská část}

Webová aplikace bude napsána pomocí jazyků a nástrojů vhodných pro vývoj webových aplikací. Používáme tedy značkovací jazyk \gls{html} pro strukturu samotné webové stránky, pro stylování objektů je použit jazyk \gls{css}. Hlavní vlastnosti stránky, jako je zobrazení entit do mapy je použitý jazyk \gls{js}, zejména pak jeho možností pro zacházení s \gls{dom} elementy. Pro připojení a načítání dat ze serveru se používá technologie \gls{ajax}ových dotazů.

\bigbreak

Koncepce klientské aplikace je taková, že žádná data nezpracovává ani nepřepočítává a zobrazuje jen data taková, která obdržela od serverové strany typicky ve formátu \gls{geojson}. Pro aktualizi dat je potřeba vyvolat nový dotaz, typycky se stejnými parametry.

\bigbreak

Webová aplikace bude v pravidelných intervalech aktualizovat obraz všech vozidel. Dále pak bude reagovat na uživatelské vstupy v podobě klikání na vybrané elementy. Ty potom vykreslí do mapy odlišeně nebo stáhne přídavná data k zobrazení.

\subsubsection{Mapbox API}

Nejprve si popišme jaké funkce budeme využívat z knihovny Mapbox.

\bigbreak

Prostředí Mapbox je široce využívaný multiplatformový nástroj pro zobrazení mapového podkladu a umožňuje do něj zanést širokou škálu různých geometrických útvarů. Tak že mapové prostředí intuitivně interaguje s uživatelem a vývojáři mohou využití jednoduchécho \gls{api} pro zobrazení žádoucích dat do mapy.

\bigbreak

Webová aplikace této práce využívá naprosto základní funkcionality, které mapbox přináší.  Popis jejich využití včetně načtení prostředí Mapboxu do webové stránky za předpokladu, že jsou splněny základní \gls{html} požadavky webové stránky je následující.

\bigbreak

Rozhraní se do webové stránky importuje pomocí:

\begin{code}[frame=none]
<script src='https://api.tiles.mapbox.com/
  mapbox-gl-js/v1.4.0/mapbox-gl.js'></script>
<link href='https://api.tiles.mapbox.com/
  mapbox-gl-js/v1.4.0/mapbox-gl.css' rel='stylesheet' />
\end{code}

\bigbreak

Dále je potřeba vytvořit element s identifikátorem webové stránky, kde bude mapa zobrazena.

\bigbreak

Po naiportovéní je v JavaScriptu k dispozici knihovna jménem \verb-mapboxgl- pomocí, které se ovládá celé mapové prostředí. Tedy je tedˇ možné vytvořit samotnou mapu.

\begin{code}[frame=none]
var map = new mapboxgl.Map({
  container: 'map', // identifikátor HTML elementu
  style: 'mapbox://styles/mapbox/streets-v11',
  center: [14.42, 50.08], // střed mapy při inicializaci [lng, lat]
    zoom: 10 // zoom při inicializaci
});
\end{code}

Nyní stačí jen vytvořit \gls{html} element za pomocí \gls{js} a po té může být přidám do mapy následující funkcí. Nyní se nám již takový element zobrazuje v mapě na zvolených souřadnicích.

\begin{code}[frame=none]
new mapboxgl.Marker(element)
  .setLngLat([Lng, Lat]) // zeměpisná výška a šířka
    umítění elementu
  .addTo(map);
\end{code}

Pro vykreslení složitějších objektů, jako je třeba lomená čára se využívá funkce \verb-addLayer-. Tato funkce přijímá data ve formátu \gls{geojson} tedy není třeba dělat žádnou trasnformaci dat.

\begin{code}[frame=none]
map.addLayer({
  "id": id, // identifikátor vrstvy
  "type": "line", // geometrický útvar k zobrazení
  "source": {
    "type": "geojson", // formát zdrojových dat
    "data": data // zdroj dat
  },
  "paint": {
    "line-color": "#BF93E4", // barva
    "line-width": 5 // šířka
  }
});
\end{code}

K manipulaci s objekty typu \verb-Layer- se používají následující funkce.

\begin{code}[frame=none]
map.getLayer(id);
map.removeLayer(id);
\end{code}

To je vše co potřebujeme k naplnění cíle vizualizace dat. Autobus na mapě budeme reprezentovat kolečkem s číslem spoje a zastávku jako špendlík, toto jsou \gls{html} elementy. Lomené čáry trasy spoje vykreslíme jako vrstvu funkcí \verb-addLayer-.

\subsubsection{Běh aplikace}

Se serverovou částí se komunikuje pomocí \verb-GET- requestů a server vrací \gls{json}onové soubory. Webová aplikace používá knihovnu na parsování tohoto formátu a tedy můžeme se k nim chovat jako k mapám.

\bigbreak

Po inicializaci prostředí Mapboxu popsanou výše následuje inicializace naší aplikace. Především se pak spustí smyčka aktualizující aktuální polohy vozidel.

\begin{code}[frame=none]
var vehicles = new Set(); // elementy vozidel v mape
var active_trips = {}; // vybraná vozidla
var vehicles_elements = {}; // html elementy vozidel
var no_stop_chosen = true; // indikátor vybrání zastávky

// inicializační stažení poloh vozidel
getFileByAJAXreq("vehicles_positions", showBusesOnMap);

// hlavní smyčka
window.setInterval(function(){
getFileByAJAXreq("vehicles_positions", showBusesOnMap);

// aktualizace ocasu všech vybraný vozidel
for (var trip in active_trips){
  active_trips[trip].update_tail();
}
}, 10000);
\end{code}

Po načtení poloh vozidel probíhá jejich vykreslování do mapy. Nejprve se odstraní z mapy všechny staré vozidla a pro každé nové vozdilo se konstruuje nový \gls{html} element. Každý tento element reprezentující vozidlo poslouchá na kliknutí.

\bigbreak

Tedy pokud vozidlo není vybráno vytvoří se nový element a následně se vykreslí do mapy a zárovenˇ se stáhnou další informace o vozidle, které se též následně zobrazují. Jsou jimi trasa vozidla, jízdní řád a zpoždění. Vybrané vozidlo se v ko'du reprezentuje vlastní třídou \verb-Active_trip-, každá instace této třídy se přidá do promněné \verb-active_trips-. Tato třída pak obsahuje metody obstarávající zobrazení dalších informací, stejně tak jejich odstranění nebo aktualizaci.

\bigbreak

Pokud vozidlo již bylo vybráno jednoduše se odstraní z množiny vybraných vozidel \verb-active_trips- a z mapy.

\bigbreak

V případě, že je nějaké vozidlo vybráno, zobrazují se i jeho zastávky. Každá zobrazená zastávka reaguje na kliknutí a na přejetí myší. Po kliknutí se vyberou všechny spoje projíždějící zastávkou a po přejetí myší se zobrazí název zastávky. Tyto funkcionality se \gls{html} elementu přiřadí následujícím ko'dem.

\begin{code}[frame=none]
// zobrazí všechny spoje projíždějící zastávkou
el_c.addEventListener('click', function() {
  no_stop_chosen = false;
  show_trips_by_stop(getFileByAJAXreqNoCallback(
    "trips_by_stop." + marker.name
  ), marker.name);
});

// přidá do mapy název zastávky po najetí myší
el_c.addEventListener("mouseover", function(){
  var el_s = document.createElement('div');
  el_s.innerText = marker.name;
  el_s.setAttribute("class", "stop_pin_sign");
  new mapboxgl.Marker(el_s)
    .setLngLat(marker.geometry.coordinates)
    .addTo(map);
});

// odebere všechny názevy zastávek z mapy po vyjetí myši
el_c.addEventListener("mouseout", function(){
  var signs = document.getElementsByClassName('stop_pin_sign');
  while(signs[0]) {
    signs[0].parentNode.removeChild(signs[0]);
  }
});
\end{code}

Vybraná vozidla podle zastávky se pak chovají stejně jako když je vybrané pouze jedno vozidlo. Tedy do promněné \verb-active_trips- se vloží více vozidel.

\subsection{Serverová část}

Tak jak je řečeno příchozí požadavky od klineta jsou odpovídáný skriptem na serverové straně. Který je napojený na databázi a z ní extrahuje potřebná data.

\bigbreak

Data jsou posílána v textové podobě ve formátu \gls{geojson}, které skrip konstruuje z dat získaných z databáze.

\bigbreak

Server reaguje na 4 typy požadavků:

\begin{itemize}
	\item \verb-get_vehicle_positions- vrátí aktuální polohy všech vozidel,

	\item \verb-get_tail.id_trip- vrátí lomenou čáru popisující pohyb vozidla v uplynulých $n$ minutách, vozidla podle identifikátoru jízdy,

	\item \verb-get_shape.id_trip- vrátí lomenou čáru popisující trasu spoje podle id spoje, vozidla podle identifikátoru jízdy,

	\item \verb-get_stops.id_trip- vrátí seznam zastávek pro spoj podle jeho id, vozidla podle identifikátoru jízdy.
\end{itemize}

Celý server je stejně jako jádro systému naprogramováno v jazyce Python3.

\subsubsection{Server knihovna}

Server je naprogramovám pomocí Pythoní knihovny \verb-simple_server-, která slouží pouze k debugování, jak se píše v její dokumentaci\footnote{$https://docs.python.org/3/library/wsgiref.html\#module-wsgiref.simple_server$}. Protože se nepočítá s reálným nasezením této aplikace, není potřeba programovat robustní server. Pro demonstrační účely je však toto řešení dostatečné.

\bigbreak

Vytvoření serveru pomocí této knihovny se v jazyce Python3 udělá následovně.

\begin{code}[frame=none]
httpd = make_server("", self.PORT, self.server)
thread = threading.Thread(target=httpd.serve_forever)
thread.start()
\end{code}

Kde \verb-server- je funkce, která je vždy volána když server obdrží dotaz. Upozorněme, že tento způsob startu serveru je odlišný od popisu v dokumentaci.

\bigbreak

Volaná funkce \verb-server- je kompletní gls{WSGI} aplikace, jež příjmá argumenty \verb-environ-, což je dotaz a atribut \verb-start-response-, který reprezentuje hlavičku odpovědi. Dále se v této funkci nachází veškerá logika serveru, tedy reaguje na parametry dotazu.

\bigbreak

Zpracování dotazu funguje pro všechny kombinace parametrů dotazu podobně. Vždy se data čtou z databáze a transformují se do formátu /gls{geojson}. Uvedˇme si na příkladu jak probíhá zpracování dotazu na zastávky daného spoje. Po té co obdržíme dotaz se z něj přečtou parametry. Pro dotaz na zastávky musí být parametr ve formátu \verb-get_stops.id_trip-. Parsování dotazu a volání příslušní interní funkce se provádí následovně.

\begin{code}[frame=none]
elif "stops" == request_body.split('.')[0]:
  response_body = json.dumps(self.get_stops(
    request_body[request_body.index('.')+1:]))
\end{code}

Funkce \verb-get_stops- přijímá identifikátor jízdy jako parametr a podle něj čte data z databáze pomocí \gls{sql} dotazu. Po přečtení dat vytváří mapu, která se snadno převede na řetězec ve formátu \gls{geojson}. Tělo funkce tedy vypadá takto:

\begin{code}[frame=none]
stops = self.database_connection.execute_fetchall("""
SELECT
  stops.lon,
  stops.lat,
  rides.departure_time,
  stops.stop_name
FROM rides
INNER JOIN stops ON rides.id_stop = stops.id_stop
WHERE rides.id_trip = %s
ORDER BY rides.shape_dist_traveled""",
(id_trip,)
)

stops_geojson = {}
stops_geojson["type"] = "FeatureCollection"
stops_geojson["features"] = []

for stop in stops:
stops_geojson["features"].append({
  "name": stop[3],
  "departure_time": stop[2].total_seconds(),
  "geometry": {
    "coordinates": [float(stop[0]), float(stop[1])]
  }
})

return stops_geojson
\end{code}



















%f
