%%% Fiktivní kapitola s instrukcemi k PDF/A

\chapter{Algoritmus odhadu zpoždění}

Tato kapitola pospisuje hledání optimálního modelu pro popis pohybu vozidel na trase.

\bigbreak

Z toho jak je problém formulován vyplývá, že se má odhadovat zpoždění mezi dvěma refenčními body a jediné takové jsou zastávky na trase danného spoje. Proto cíl algortimu může být formulován jako vytvořit popis průběhu trasy mezi každou dvojcí zastávek, které alespoň jeden spoj obsluhuje a jsou bezprostředně sousedící ve sledu zastávek ve směru jízdy tohoto spoje. Nechtˇ se dvojce bodů a spoj je obsluhůjící splňující předcházející předpoklad označuje jako A, B a S.

\section{Základní předpoklady}

Hned na začátek je potřeba ustanovit základní předpoklady ze kterých bude vycházet sestrojený algoritmus.

\bigbreak

Zastávky je potřeba rozlišovat na jednotlivá nástupiště. Toto výrazně nezvýší počet dvojic zastávek A a B. -- Naprostá většina zastávek má pouze dvě nástupiště. Pro každý směr jedno. Pokud má více nástupištˇ, pak tak bývá v případech, kdy ze zastávky odjíždí spoje do více směrů a tudíž pro každné nástupiště je jiná následující zastávka.

\bigbreak

Všechny spoje S bez ohladu na linku nebo dopravce jedou ze zastávky A do zastávky B po stejné trase a tedy vzdálenost je konstatní. -- Předpokládá se, že žáný dopravce nevyužívá jinou komunikaci a pro všechny platí pravidla silničního provozu stejně.

\bigbreak

Čas jízdy ze zastávky A do B závisí pouze na denní době. -- Vysvětleno výše. Navíc platí žádný z dopravců nedisponuje právem přednosti v jízdě před jiným dopravcem nebo výrazně výkonějším vozidlem.  Dojezdové časy mohou být ovlivněny jen charakterem řidiče, avšak toto není zjistitelné z poskytnutých dat a zároveň se předpokládá, že charatery řidičů jsou rovnoměrně rozloženy mezi všechny dopravce a linky. Podle jízdních řádů některé linky jedou ve stejnou denní dobu rychleji než jiné, avšak skutečné doba jízdy je stejná. To že některý spoj zastávku projíždí a tím je rychlejší než jiný spoj není porušení tohoto předpokladu protože se jedná o dvě různé dvojce zastávek.

\bigbreak

Během jízdy mohou nastat mimořádnosti, které porušují výše uvedené předpoklady, nicméně detekce mimořádností a jejich řešení je nad rámec této práce a jejich počet je zanedbatelný, proto na statistické modely nebudou mít vliv.


\subsection{Analýza dat}

Z dat popsaných v kapitole (TODO link kap 2???) je potřeba získat všechny dvojce zastávek A, B a všechny oznámené polohy vozidel mezi nimi. Toto je možné z databáze popsané v kapitole (TOTO link pak 3) zjistit pomocí jízdních řádů a dále pomocí atributu \verb-dist_shape_traveled- uvedého u každé zastávky pro každý spoj získat i jednotlivé polohy vozidel.

\bigbreak

Toto je možné realizovat pomocí následujícího \gls{sql} dotazu.

TODO upravit a vylepsit tento dotaz, do jake miry mam uvadet vsechny pouzite sql dotazy???
\begin{code}[frame=none]
select inn.id_trip,
	inn.id_stop,
	inn.lead_stop,
	departure_time,
	inn.lead_stop_departure_time,
	(inn.lead_stop_shape_dist_traveled - inn.shape_dist_traveled) as diff_shape_trav,
	trip_coordinates.inserted,
	(trip_coordinates.shape_dist_traveled - inn.shape_dist_traveled) as shifted_shape_trav,
	trip_coordinates.delay
FROM (
	SELECT id_trip, id_stop, shape_dist_traveled, departure_time,
		LEAD(id_stop, 1) OVER (PARTITION BY id_trip ORDER BY shape_dist_traveled) lead_stop,
		LEAD(shape_dist_traveled, 1) OVER (PARTITION BY id_trip ORDER BY shape_dist_traveled) lead_stop_shape_dist_traveled,
		LEAD(departure_time, 1) OVER (PARTITION BY id_trip ORDER BY shape_dist_traveled) lead_stop_departure_time
	FROM rides) as inn
	JOIN trip_coordinates
	ON trip_coordinates.id_trip = inn.id_trip and inn.lead_stop_shape_dist_traveled - inn.shape_dist_traveled > 1500 and trip_coordinates.shape_dist_traveled between inn.shape_dist_traveled and inn.lead_stop_shape_dist_traveled
\end{code}

\bigbreak

Nyní je pro představení si situalce uvedeno několik vizualizací těchto dat. Zejména pak s důrazem na rozlišnosti mezi průběhy tras mezi různými dvojcemi zastávek.

\bigbreak

Všechny diagramy níže a posléze algoritmy pracují s těmito daty jako body třírozměrného prostoru. Každý tento bod reprezentuje jedno hlášení o poloze vozidla. První dimenze bodu je denní doba (v grafech znázorněno jako počet sekund od půlnoci), druhá dimenze je vzdálenost od výchozí zastávky (znázorněno jako počet metrů) a třetí dimenze reprezentuje čas od vyjetí z výchozí stanice (počet sekund).

TODO obrazky kratka trasa s moc nekonzistentnimi daty, dlouha trasa hladka, dlouha trasa s anomaliemi, trasy s nedostatkem dat, trasy kde jsou pekne videt krizovatky (cca 5 prikaldu)


\section{Návrh modelu}

Z výše uvedených vizualizací dat vyplývá, že hledání univerzálního modelu popisující všechny možné průběhy tras je nereálné.

\bigbreak

Lepší je různé průběhy tras rozdělit podle jejich vlastností do kategorií a pro každou použít jiný model. Použité dílčí modely jsou:


\subsection{Lineární model}

Ačkoli je snaha tento model nahradit lepším, v některých situacích může jeho použití i na dále dávat smysl. Zejména pak v případech kdy není k dispozici dostatek dat a nebo je vzdálenost dvou zastávek natolik malá, že nemá smyl ani jakýkoliv odhat zpoždění dělat. (TODO do problemu: Lepší by bylo volit trasy s nejmenší dobou jízdy, ale čas jízdy je promněnlivý a težko se získá skutečná doba jízdy z dat. Navíc v praxi jsou vzdálenost a doba jízdy dostatečně závislé)

(TODO obrázek lineárního modelu)


\subsection{Polynomiální model}

Polynomiální model se hodí pro situace kdy je průběh trasy nějak ovlivněn vždy ve stejném úseku a má vliv na každý projíždějící spoj. Nebo se v průběhu dne pozvolna mění v závislosti na dopravním vytížení projížděných úseků.

\bigbreak

K tomuto dochází například v případech kdy spoj zastavuje ve městě a v následujících několika málo kilometrech jede pomaleji, poté zrychlý a dále opět vjede do města. Takový model se hodí spíše na delší trasy s plynulou jízdou.

\bigbreak

Pro spočítání polynomiálního modelu se využívá knihovna sklearn konkrétně algoritmus zvaný Rigde, který sám o sobě hledá linární závislosti, nicméně vstupní hodnoty jsou mezi sebou náležitě pronásobeny tak, aby simulovali polynomiální funkci. Toho se dosáhne pomocí funkce PolynomialFeatures. Optimální stupeň polynomu se zjistí spočítáním modelu pro každý stupeň v rozumných mezích a nakonec se zvolí ten s nejmenší chybou. (TODO jak moc detailně se ma toto popisovat?)

(TODO obrazek poly modelu)

\bigbreak

Jako odhad zpoždění se pak vrací rozdíl skutečného počtu sekund na trase a predikce modelu. To celé se pak ještě přičítá k rozdílu predikce v modelu v čase a vzdálenosti příjezdu podle jízdního řádu a pravidelného příjezdu.


\subsection{Model pomocí konkávního obalu}

Posledním a nejkomplikovanějším modelem, zasluhující nejvíce pozornosti, je popsání trasy za pomocí konkávního obalu bodů.

\bigbreak

Tato metoda vznikla jako řešení situace, kdy na trase exituje bod, který určité procento projíždějících spojů zdrží o netriviální dobu. Něco takového nastane pokud spoje projíždí světelnou křižovatkou nebo místem přek kterým se tvoří kolona vozidel. Zde dochází ke skové změně průběhu bodové funkce a spojité modely by s okolím tohoto kritického místa měly problém. Pro jeden takový bod by možná šlo navrhnout jednoduší řešení, nicméně je potřeba algoritmus, který umí pracovat s více kritickými body na trase. Například je nutné poradit si se situací zobrazené na diagramu (TODO link na obrazek), kde jsou na trase takové kritické body dva. V této modelové situaci je pro jednoduchost uvažováno, že se většina projíždějících spojů zdrží v prvním kritickém bodě, nebo v druhém, nebo se lehce zdrží v obou. S takovým zdržením je počítáno v jízdním řádu a tedy vozidla, která projedou první kritický bod bez zdrření jedou na čas stejně tak, jako vozidla v něm zdržená. O snížení nebo zvýšení případného zpoždění spoje je možno rozhodnout až po projetí druhého bodu. Jinými slovy na ose uplynulého času od vyjetí ze zastávky vzniká jakýsi podprostor v němž se zpoždění nemění. Pro jeho popis se využívá právě konkávní obal všech spojů, které přijely včas.


\subsubsection{Problémy}

Ačkoli je myšlenka jednoduchá, při implementaci vyvstává několik technických problémů.

\bigbreak

Nejprve k samotnému konkávnímu obalu. Je potřeba říct, že na množině bodů není definován jednoznačně (TODO obrazek nejednoznacnosti konkavnoho obalu). A jedná se o početně složitý algoritmus. V tomto díle je zapotřebí spočítat obal ve třídimenzionálním prostoru, což je velmi komplikovaný úkol, a proto je potřeba přijít s zjednodušením úlohy. Tedy počítat obal pouze pro dvoudimenzionální prostor. Toho se nedá dosáhnou jinak než diskretizací úlohy a počítání obalu pro každou hodinu zvláštˇ, tedy ze všech bodů, které byly zaznamenány v průběhu jedné hodiny. Tím může dojít k vetší granularitě obalu, než by bylo vhodné, nicméně předpokládá se, že hodina je dostatečně dlouhý časový interval na to, aby zde byly zachyceny všechny druhy průběhu jízdy (započítávají se všechny spoje jedoucí ve stejnou hodiny nejméně týden zpět) a zároveň je to dostatečně krátký interval na nezkreslování denních výkyvů v čase jízdy. Navíc všechny body tvořící obal pro dannou hodinu jsou poté přidány do celkového obalu i s přesným časem zaznamenání a pro počítání konečných výsledků je použit třídimenzionální obal.

\bigbreak

Dále se jako netriviální ukazuje detekce spojů, které přijely včas a tedy všechny jejich body mají být předány k výpočtu obalu. Nabízí se použít data o všech spojí, které přijely do cílové zastávky s co nejmenším zpožděním, ale je nutné mít na paměti, že příjezdy podle jízdního řádu nemusí vůbec odpovídat realitě. Proto se zdá být nejlepší použít data od spojů, které přijely ve stejnou dobu jako je průměr všech příjezdů do cílové zastávky. Toho se docílí tak, že se poslední body podle vzdálenosti všech spojů použijí pro odhat času příjezdu. Zobrazeno na diagramu (TODO link na obrazek odhat prijezdu). Dále se pro každou hodinu seřadí všechny spoje podle vzdálenosti odhadnutého příjezdu od skutečného a použije se určité procento nejbližších spojů k tomuto odhadu.

\bigbreak

Z předchozího popisu řešení vyplývá ovšem, že pro výpočet obalu jsou použity spoje, které ani zdaleka nemusely přijet včas jak je požadováno, ale předpokládá se, že se nepříliš vzdalují od průměrného času příjezdu. To že střední zpoždění pro celý obal není nulové se vyřeší spočtením odchylky průměrného příjezdu od příjezdu podle jízdního řádu a následně přičtení této konstanty k odhadnutnému zpoždění. Každopádně to, že rozptyl příjezdů spojů zahrnutých ve výpočtu obalu může být netriviální, vyžaduje nahlížet na tento obal jako na lineární prostor pohybu zpoždění. Tedy že odhat zpoždění pro bod nacházející se v obalu je lineárně závislý na vzdálenosti od hranice obalu, avšak protože je známo časové rozpětí příjezdu spojů použitých pro výpočet obalu, je možné tuto vzdálenost snadno přenést na skutečné pozdění.


\subsubsection{Popis algoritmu}

Po popsání a vyřešení všech komplikací je možné nastínit průběh algoritmu.

\bigbreak

Nejprve konstrukce konkávního obalu:

\begin{code}[frame=none]
poslední_čas = vyber všechny poslední body podle vzdálenosti od každého spoje
odhad_příjezdu = odhadni čas příjezdu v průběhu celého dne podle bodů v poslní_čas
spoje_včas = prázdné pole

pro každou hodinu h:
	spoje_včas += vyber x \% spojů, které přijely nejblíže odhadu v hodině h

konkávní_obal = prázdné pole

pro každou hodinu h:
	body = vyber všechny body zaznamenané v hodině h a náležící kterémukili spoji v spoje_včas
	konkávní obal += spočítej konkávní obal z body

Vrací: konkávní_obal
\end{code}

Dále odhad zpoždění z konkávního obalu:

\begin{code}[frame=none]
Vstup: bod v prostoru vzdálenosti, průběhu dne a času na trase

pokud je bod v konkávní_obal:
	velikost_okna = rozdíl horní hranice obalu od spodní v čase příjezdu do zastávky
	spodek_okna = spodní hranice okna v čase příjezdu do zastávky
	poměr = vzdálenost bodu od spodní hranice obalu / vzdálenost bodu od horní hranice obalu
	odhad_příjezdu = velikost_okna * poměr + spodek_okna
jinak:
	pokud je bod pod obalem:
		spodek_okna = spodní hranice obalu v čase příjezdu do zastávky
		odhad_příjezdu = spodek_okna - vzdálenost bodu od obalu
	jinak:
		vrch_okna = horní hranice obalu v čase příjezdu do zastávky
		odhad_příjezdu = vrch_okna + vzdálenost bodu od obalu

Vrací: odhad_příjezdu - pravidelný příjezd
\end{code}













































f
